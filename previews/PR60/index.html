<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PrecompileTools.jl</title><meta name="title" content="Home · PrecompileTools.jl"/><meta property="og:title" content="Home · PrecompileTools.jl"/><meta property="twitter:title" content="Home · PrecompileTools.jl"/><meta name="description" content="Documentation for PrecompileTools.jl."/><meta property="og:description" content="Documentation for PrecompileTools.jl."/><meta property="twitter:description" content="Documentation for PrecompileTools.jl."/><meta property="og:url" content="https://JuliaLang.github.io/PrecompileTools.jl/"/><meta property="twitter:url" content="https://JuliaLang.github.io/PrecompileTools.jl/"/><link rel="canonical" href="https://JuliaLang.github.io/PrecompileTools.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PrecompileTools.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Tutorial:-forcing-precompilation-with-workloads"><span>Tutorial: forcing precompilation with workloads</span></a></li><li><a class="tocitem" href="#Tutorial:-local-&quot;Startup&quot;-packages"><span>Tutorial: local &quot;Startup&quot; packages</span></a></li><li><a class="tocitem" href="#Tutorial:-&quot;healing&quot;-invalidations"><span>Tutorial: &quot;healing&quot; invalidations</span></a></li><li><a class="tocitem" href="#When-you-can&#39;t-run-a-workload"><span>When you can&#39;t run a workload</span></a></li><li><a class="tocitem" href="#Troubleshooting"><span>Troubleshooting</span></a></li><li><a class="tocitem" href="#Package-developers:-reducing-the-cost-of-precompilation-during-development"><span>Package developers: reducing the cost of precompilation during development</span></a></li><li><a class="tocitem" href="#Seeing-what-got-precompiled"><span>Seeing what got precompiled</span></a></li></ul></li><li><a class="tocitem" href="invalidations/">Invalidations</a></li><li><a class="tocitem" href="explanations/">How PrecompileTools works</a></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaLang/PrecompileTools.jl/" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaLang/PrecompileTools.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="PrecompileTools"><a class="docs-heading-anchor" href="#PrecompileTools">PrecompileTools</a><a id="PrecompileTools-1"></a><a class="docs-heading-anchor-permalink" href="#PrecompileTools" title="Permalink"></a></h1><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p><code>PrecompileTools</code> is designed to help reduce delay on first usage of Julia code. It can force <em>precompilation</em> of specific workloads; particularly with Julia 1.9 and higher, the precompiled code is automatically saved to disk, so that it doesn&#39;t need to be compiled freshly in each Julia session. You can use <code>PrecompileTools</code> as a package developer, to reduce the latency experienced by users of your package for &quot;typical&quot; workloads; you can also use <code>PrecompileTools</code> as a user, creating custom &quot;Startup&quot; package(s) that precompile workloads important for your work.</p><p>The main tool in <code>PrecompileTools</code> is a macro, <code>@compile_workload</code>, which precompiles all the code needed to execute the workload. It also includes a second macro, <code>@setup_workload</code>, which can be used to &quot;mark&quot; a block of code as being relevant only for precompilation but which does not itself force compilation of <code>@setup_workload</code> code. (<code>@setup_workload</code> is typically used to generate test data using functions that you don&#39;t need to precompile in your package.) Finally, <code>PrecompileTools</code> includes <code>@recompile_invalidations</code> to mitigate the undesirable consequences of <em>invalidations</em>. These different tools are demonstrated below.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The latency reductions from PrecompileTools are maximally effective for Julia versions 1.9 and higher, and intermediate for Julia 1.8. Julia versions 1.7 and earlier may see some limited benefit as well, but have also occasionally been found to suffer from <a href="https://github.com/JuliaLang/julia/issues/35972">precompilation-induced runtime performance regressions</a>. If you wish, you can disable precompilation on older Julia versions by wrapping precompilation statements (see below) with <code>if Base.VERSION &gt;= v&quot;1.8&quot; ... end</code>. On older Julia versions, you may wish to test packages for performance regressions when introducing precompilation directives.</p></div></div><h2 id="Tutorial:-forcing-precompilation-with-workloads"><a class="docs-heading-anchor" href="#Tutorial:-forcing-precompilation-with-workloads">Tutorial: forcing precompilation with workloads</a><a id="Tutorial:-forcing-precompilation-with-workloads-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-forcing-precompilation-with-workloads" title="Permalink"></a></h2><p>No matter whether you&#39;re a package developer or a user looking to make your own workloads start faster, the basic workflow of <code>PrecompileTools</code> is the same. Here&#39;s an illustration of how you might use <code>@compile_workload</code> and <code>@setup_workload</code>:</p><pre><code class="language-julia hljs">module MyPackage

using PrecompileTools: @setup_workload, @compile_workload    # this is a small dependency

struct MyType
    x::Int
end
struct OtherType
    str::String
end

@setup_workload begin
    # Putting some things in `@setup_workload` instead of `@compile_workload` can reduce the size of the
    # precompile file and potentially make loading faster.
    list = [OtherType(&quot;hello&quot;), OtherType(&quot;world!&quot;)]
    @compile_workload begin
        # all calls in this block will be precompiled, regardless of whether
        # they belong to your package or not (on Julia 1.8 and higher)
        d = Dict(MyType(1) =&gt; list)
        x = get(d, MyType(2), nothing)
        last(d[MyType(1)])
    end
end

end</code></pre><p>When you build <code>MyPackage</code>, it will precompile the following, <em>including all their callees</em>:</p><ul><li><code>Pair(::MyPackage.MyType, ::Vector{MyPackage.OtherType})</code></li><li><code>Dict(::Pair{MyPackage.MyType, Vector{MyPackage.OtherType}})</code></li><li><code>get(::Dict{MyPackage.MyType, Vector{MyPackage.OtherType}}, ::MyPackage.MyType, ::Nothing)</code></li><li><code>getindex(::Dict{MyPackage.MyType, Vector{MyPackage.OtherType}}, ::MyPackage.MyType)</code></li><li><code>last(::Vector{MyPackage.OtherType})</code></li></ul><p>In this case, the &quot;top level&quot; calls were fully inferrable, so there are no entries on this list that were called by runtime dispatch. Thus, here you could have gotten the same result with manual <code>precompile</code> directives. The key advantage of <code>@compile_workload</code> is that it works even if the functions you&#39;re calling have runtime dispatch.</p><p>Once you set up a block using <code>PrecompileTools</code>, try your package and see if it reduces the time to first execution, using the same workload you put inside the <code>@compile_workload</code> block.</p><p>If you&#39;re happy with the results, you&#39;re done! If you want deeper verification of whether it worked as expected, or if you suspect problems, the <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile package</a> provides diagnostic tools. Potential sources of trouble include invalidation (diagnosed with <code>SnoopCompileCore.@snoop_invalidations</code> and related tools) and omission of intended calls from inside the <code>@compile_workload</code> block (diagnosed with <code>SnoopCompileCore.@snoop_inference</code> and related tools).</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>@compile_workload</code> works by monitoring type-inference. If the code was already inferred prior to <code>@compile_workload</code> (e.g., from prior usage), you might omit any external methods that were called via runtime dispatch.</p><p>You can use multiple <code>@compile_workload</code> blocks if you need to interleave <code>@setup_workload</code> code with code that you want precompiled. You can use <code>@snoop_inference</code> to check for any (re)inference when you use the code in your package. To fix any specific problems, you can combine <code>@compile_workload</code> with manual <code>precompile</code> directives.</p></div></div><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>@compile_workload</code> should go at &quot;top level,&quot; not compiled into a function. A pattern like <code>withenv(...) do @compile_workload begin ... end end</code>, where <code>@compile_workload</code> appears in the anonymous function passed to <code>withenv</code>, may defeat some of the value of PrecompileTools.</p></div></div><h2 id="Tutorial:-local-&quot;Startup&quot;-packages"><a class="docs-heading-anchor" href="#Tutorial:-local-&quot;Startup&quot;-packages">Tutorial: local &quot;Startup&quot; packages</a><a id="Tutorial:-local-&quot;Startup&quot;-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-local-&quot;Startup&quot;-packages" title="Permalink"></a></h2><p>Users who want to precompile workloads that have not been precompiled by the packages they use can follow the recipe above, creating custom &quot;Startup&quot; packages for each project. Imagine that you have three different kinds of analyses you do: you could have a folder</p><pre><code class="nohighlight hljs">MyData/
  Project1/
  Project2/
  Project3/</code></pre><p>From each one of those <code>Project</code> folders you could do the following:</p><pre><code class="nohighlight hljs">(@v1.9) pkg&gt; activate .
  Activating new project at `/tmp/Project1`

(Project1) pkg&gt; generate Startup
  Generating  project Startup:
    Startup/Project.toml
    Startup/src/Startup.jl

(Project1) pkg&gt; dev ./Startup
   Resolving package versions...
    Updating `/tmp/Project1/Project.toml`
  [e9c42744] + Startup v0.1.0 `Startup`
    Updating `/tmp/Project1/Manifest.toml`
  [e9c42744] + Startup v0.1.0 `Startup`

(Project1) pkg&gt; activate Startup/
  Activating project at `/tmp/Project1/Startup`

(Startup) pkg&gt; add PrecompileTools LotsOfPackages...</code></pre><p>In the last step, you add <code>PrecompileTools</code> and all the package you&#39;ll need for your work on <code>Project1</code> as dependencies of <code>Startup</code>. Then edit the <code>Startup/src/Startup.jl</code> file to look similar to the tutorial previous section, e.g.,</p><pre><code class="language-julia hljs">module Startup

using LotsOfPackages...
using PrecompileTools

@compile_workload begin
    # inside here, put a &quot;toy example&quot; of everything you want to be fast
end

end</code></pre><p>Then when you&#39;re ready to start work, from the <code>Project1</code> environment just say <code>using Startup</code>. All the packages will be loaded, together with their precompiled code.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If desired, the <a href="https://github.com/simonster/Reexport.jl">Reexport package</a> can be used to ensure these packages are also exported by <code>Startup</code>.</p></div></div><h2 id="Tutorial:-&quot;healing&quot;-invalidations"><a class="docs-heading-anchor" href="#Tutorial:-&quot;healing&quot;-invalidations">Tutorial: &quot;healing&quot; invalidations</a><a id="Tutorial:-&quot;healing&quot;-invalidations-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-&quot;healing&quot;-invalidations" title="Permalink"></a></h2><p>Julia sometimes <em>invalidates</em> previously compiled code (see <a href="invalidations/#Why-does-Julia-invalidate-code?">Why does Julia invalidate code?</a>). PrecompileTools provides a mechanism to recompile the invalidated code so that you get the full benefits of precompilation. This capability can be used in &quot;Startup&quot; packages (like the one described above), as well as by package developers.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Excepting <a href="https://docs.julialang.org/en/v1/manual/style-guide/#Avoid-type-piracy">piracy</a> (which is heavily discouraged), <em>type-stable (i.e., well-inferred) code cannot be invalidated.</em> If invalidations are a problem, an even better option than &quot;healing&quot; the invalidations is improving the inferrability of the &quot;victim&quot;: not only will you prevent invalidations, you may get faster performance and slimmer binaries. Packages that can help identify inference problems and invalidations include <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile</a>, <a href="https://github.com/aviatesk/JET.jl">JET</a>, and <a href="https://github.com/JuliaDebug/Cthulhu.jl">Cthulhu</a>.</p></div></div><p>The basic usage is simple: wrap expressions that might invalidate with <code>@recompile_invalidations</code>. Invalidation can be triggered by defining new methods of external functions, including during package loading. Using the &quot;Startup&quot; package above, you might wrap the <code>using</code> statements:</p><pre><code class="language-julia hljs">module Startup

using PrecompileTools
@recompile_invalidations begin
    using LotsOfPackages...
end

# Maybe a @compile_workload here?

end</code></pre><p>Note that recompiling invalidations can be useful even if you don&#39;t add any additional workloads.</p><p>Alternatively, if you&#39;re a package developer worried about &quot;collateral damage&quot; you may cause by extending functions owned by Base or other package (i.e., those that require <code>import</code> or module-scoping when defining the method), you can wrap those method definitions:</p><pre><code class="language-julia hljs">module MyContainers

using AnotherPackage
using PrecompileTools

struct Container
    list::Vector{Any}
end

# This is a function created by this package, so it doesn&#39;t need to be wrapped
make_container() = Container([])

@recompile_invalidations begin
    # Only those methods extending Base or other packages need to go here
    Base.push!(obj::Container, x) = ...
    function AnotherPackage.foo(obj::Container)
        ⋮
    end
end

end</code></pre><p>You can have more than one <code>@recompile_invalidations</code> block in a module. For example, you might use one to wrap your <code>using</code>s, and a second to wrap your method extensions.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Package developers should be aware of the tradeoffs in using <code>@recompile_invalidations</code> to wrap method extensions:</p><ul><li>the benefit is that you might deliver a better out-of-the-box experience for your users, without them needing to customize anything</li><li>the downside is that it will increase the precompilation time for your package. Worse, what can be invalidated once can sometimes be invalidated again by a later package, and if that happens the time spent recompiling is wasted.</li></ul><p>Using <code>@recompile_invalidations</code> in a &quot;Startup&quot; package is, in a sense, safer because it waits for all the code to be loaded before recompiling anything. On the other hand, this requires users to implement their own customizations.</p><p>Package developers are encouraged to try to fix &quot;known&quot; invalidations rather than relying reflexively on <code>@recompile_invalidations</code>.</p></div></div><h2 id="When-you-can&#39;t-run-a-workload"><a class="docs-heading-anchor" href="#When-you-can&#39;t-run-a-workload">When you can&#39;t run a workload</a><a id="When-you-can&#39;t-run-a-workload-1"></a><a class="docs-heading-anchor-permalink" href="#When-you-can&#39;t-run-a-workload" title="Permalink"></a></h2><p>There are cases where you might want to precompile code but cannot safely <em>execute</em> that code: for example, you may need to connect to a database, or perhaps this is a plotting package but you may be currently on a headless server lacking a display, etc. In that case, your best option is to fall back on Julia&#39;s own <code>precompile</code> function. However, as explained in <a href="explanations/#How-PrecompileTools-works">How PrecompileTools works</a>, there are some differences between <code>precompile</code> and <code>@compile_workload</code>; most likely, you may need multiple <code>precompile</code> directives. Analysis with <a href="https://github.com/timholy/SnoopCompile.jl">SnoopCompile</a> may be required to obtain the results you want; in particular, combining <code>@snoop_inference</code> and <code>parcel</code> will allow you to generate a set of <code>precompile</code> directives that can be <code>include</code>d in your module definition.</p><p>Be aware that <code>precompile</code> directives are more specific to the Julia version, CPU (integer width), and OS than running a workload.</p><h2 id="Troubleshooting"><a class="docs-heading-anchor" href="#Troubleshooting">Troubleshooting</a><a id="Troubleshooting-1"></a><a class="docs-heading-anchor-permalink" href="#Troubleshooting" title="Permalink"></a></h2><p>Ensure your workload &quot;works&quot; (runs without error) when copy/pasted into the REPL. If it produces an error only when placed inside <code>@precompile_workload</code>, check whether your workload runs when wrapped in a</p><pre><code class="nohighlight hljs">let
    # workload goes here
end</code></pre><p>block.</p><h2 id="Package-developers:-reducing-the-cost-of-precompilation-during-development"><a class="docs-heading-anchor" href="#Package-developers:-reducing-the-cost-of-precompilation-during-development">Package developers: reducing the cost of precompilation during development</a><a id="Package-developers:-reducing-the-cost-of-precompilation-during-development-1"></a><a class="docs-heading-anchor-permalink" href="#Package-developers:-reducing-the-cost-of-precompilation-during-development" title="Permalink"></a></h2><p>If you&#39;re frequently modifying one or more packages, you may not want to spend the extra time precompiling the full set of workloads that you&#39;ve chosen to make fast for your &quot;shipped&quot; releases. One can <em>locally</em> reduce the cost of precompilation for selected packages using the <code>Preferences.jl</code>-based mechanism and the <code>&quot;precompile_workload&quot;</code> key: from within your development environment, use</p><pre><code class="language-julia hljs">using MyPackage, Preferences
set_preferences!(MyPackage, &quot;precompile_workload&quot; =&gt; false; force=true)</code></pre><p>This will write the following to LocalPreferences.toml alongside your active environment Project.toml</p><pre><code class="nohighlight hljs">[MyPackage]
precompile_workload = false</code></pre><p>After restarting julia, the <code>@compile_workload</code> and <code>@setup_workload</code> workloads will be disabled (locally) for <code>MyPackage</code>. You can also specify additional packages (e.g., dependencies of <code>MyPackage</code>) if you&#39;re co-developing a suite of packages.  Simply run <code>set_preferences!</code> for the additional packages, or edit LocalPreferences.toml directly.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Changing <code>precompile_workload</code> will result in a one-time recompilation of all packages that depend on the package(s) from the current environment. Package developers may wish to set this preference locally within the &quot;main&quot; package&#39;s environment; precompilation will be skipped while you&#39;re actively developing the project, but not if you use the package from an external environment. This will also keep the <code>precompile_workload</code> setting independent and avoid needless recompilation of large environments.</p></div></div><p>Finally, it is possible to fully disable PrecompileTools.jl for all packages with</p><pre><code class="language-julia hljs">using PrecompileTools, Preferences
set_preferences!(PrecompileTools, &quot;precompile_workloads&quot; =&gt; false; force=true)</code></pre><p>This can be helpful to reduce the system image size generated when using PackageCompiler.jl by only compiling calls made in a precompilation script.</p><h2 id="Seeing-what-got-precompiled"><a class="docs-heading-anchor" href="#Seeing-what-got-precompiled">Seeing what got precompiled</a><a id="Seeing-what-got-precompiled-1"></a><a class="docs-heading-anchor-permalink" href="#Seeing-what-got-precompiled" title="Permalink"></a></h2><p>If you want to see the list of calls that will be precompiled, navigate to the <code>MyPackage</code> folder and use</p><pre><code class="language-julia hljs">julia&gt; using PrecompileTools

julia&gt; PrecompileTools.verbose[] = true   # runs the block even if you&#39;re not precompiling, and print precompiled calls

julia&gt; include(&quot;src/MyPackage.jl&quot;);</code></pre><p>This will only show the direct- or runtime-dispatched method instances that got precompiled (omitting their inferrable callees). For a more comprehensive list of all items stored in the compile_workload file, see <a href="https://github.com/timholy/PkgCacheInspector.jl">PkgCacheInspector</a>.</p></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="invalidations/">Invalidations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.9.0 on <span class="colophon-date" title="Thursday 10 April 2025 12:50">Thursday 10 April 2025</span>. Using Julia version 1.13.0-DEV.371.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
